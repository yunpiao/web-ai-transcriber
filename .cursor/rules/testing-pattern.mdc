---
description: Chrome扩展测试套路和最佳实践 - 添加新功能时必须遵循的测试模式
alwaysApply: false
---

# Chrome扩展测试套路

## 核心原则

为每个新功能创建**完整的三层测试**：
1. **单元测试** - 测试独立函数和逻辑
2. **集成测试** - 测试模块间交互
3. **E2E测试** - 测试真实浏览器环境

## 测试文件组织

```
tests/
├── unit/              # 单元测试 - 快速（<1秒）
├── integration/       # 集成测试 - 快速（<1秒）
├── e2e/              # E2E测试 - 慢（需要真实浏览器）
├── helpers/          # 测试工具（chrome-mock.js, fixtures.js）
└── fixtures/         # 测试数据和页面
```

## 标准测试套路

### 1. 单元测试模板

对于每个新功能模块，创建 `tests/unit/[功能名].test.js`：

```javascript
const { setupChromeMock, resetChromeMock } = require('../helpers/chrome-mock');
const { createMock[功能]Data } = require('../helpers/fixtures');

describe('[功能名]单元测试', () => {
  beforeEach(() => {
    setupChromeMock(); // 如果需要Chrome API
  });

  afterEach(() => {
    resetChromeMock();
  });

  test('应该能够[核心功能1]', () => {
    // Arrange - 准备数据
    const input = createMockData();
    
    // Act - 执行操作
    const result = myFunction(input);
    
    // Assert - 验证结果
    expect(result).toBe(expectedValue);
  });

  test('应该能够处理边界情况', () => {
    // 测试null、空字符串、极大值等
  });

  test('应该能够处理错误', async () => {
    await expect(myFunction(invalidInput)).rejects.toThrow();
  });
});
```

**必须测试**：
- ✅ 正常功能
- ✅ 边界情况
- ✅ 错误处理

### 2. 集成测试模板

创建 `tests/integration/[功能名].test.js`：

```javascript
const { setupChromeMock, resetChromeMock } = require('../helpers/chrome-mock');

describe('[功能名]集成测试', () => {
  beforeEach(() => setupChromeMock());
  afterEach(() => resetChromeMock());

  test('应该能够与Chrome API交互', async () => {
    // 测试与chrome.storage的交互
    await chrome.storage.sync.set({ key: 'value' });
    const result = await chrome.storage.sync.get('key');
    expect(result.key).toBe('value');
  });

  test('应该能够处理消息通信', async () => {
    // 测试content script和background的通信
    const response = await chrome.runtime.sendMessage({
      action: 'testAction',
      data: {}
    });
    expect(response.success).toBe(true);
  });
});
```

### 3. E2E测试模板

创建 `tests/e2e/[功能名].test.js`：

```javascript
const {
  launchBrowserWithExtension,
  getExtensionId,
  openExtensionPage,
  wait
} = require('./setup');

describe('[功能名]E2E测试', () => {
  let browser;
  let extensionId;

  beforeAll(async () => {
    browser = await launchBrowserWithExtension();
    extensionId = await getExtensionId(browser);
  });

  afterAll(async () => {
    if (browser) {
      await browser.close();
    }
  });

  test('应该能够在真实环境中工作', async () => {
    // 1. 配置功能
    const optionsPage = await openExtensionPage(browser, extensionId, 'options.html');
    await optionsPage.click('#enable-feature');
    await optionsPage.click('#save');
    await wait(1000);
    await optionsPage.close();
    
    // 2. 访问真实网页（使用https://网页，不是file://）
    const testPage = await browser.newPage();
    await testPage.goto('https://www.baidu.com');
    await wait(2000);
    
    // 3. 验证功能效果
    const result = await testPage.evaluate(() => {
      return /* 检查页面状态 */;
    });
    
    expect(result).toBe(expected);
    await testPage.close();
  });
});
```

## 关键注意事项

### Chrome扩展特有的限制

1. **Content Scripts只在特定URL工作**：
   - ✅ `https://` 和 `http://` 网页
   - ❌ `chrome-extension://` 扩展页面
   - ❌ `file://` 本地文件
   - ❌ `about:` 和 `chrome://` 特殊页面

2. **E2E测试必须使用真实网页**：
   ```javascript
   // ✅ 正确
   await page.goto('https://www.baidu.com');
   
   // ❌ 错误 - content script不会加载
   await page.goto('file:///path/to/test.html');
   await page.goto('about:blank');
   ```

3. **Puppeteer的page.evaluate无法访问扩展API**：
   ```javascript
   // ❌ 这个会返回false，即使扩展正常工作
   const hasChrome = await page.evaluate(() => {
     return typeof chrome !== 'undefined';
   });
   
   // ✅ 正确做法：通过功能效果来验证
   // 比如检查IndexedDB中的数据、页面上的元素等
   ```

4. **需要等待content script加载**：
   ```javascript
   await page.goto('https://example.com');
   await wait(2000); // 等待content script注入
   ```

### IndexedDB测试

使用 `fake-indexeddb` 时，需要polyfill：

参考 [tests/setup.js](mdc:tests/setup.js)：
```javascript
if (typeof global.structuredClone === 'undefined') {
  global.structuredClone = (val) => {
    return JSON.parse(JSON.stringify(val));
  };
}
```

### Jest配置

参考 [jest.config.js](mdc:jest.config.js) 和 [jest.e2e.config.js](mdc:jest.e2e.config.js)：

- **单元/集成测试**：使用 `testEnvironment: 'jsdom'`
- **E2E测试**：使用 `testEnvironment: 'node'`（需要单独配置文件）

## 测试数据管理

### 在helpers/fixtures.js中创建测试数据生成器

参考 [tests/helpers/fixtures.js](mdc:tests/helpers/fixtures.js)：

```javascript
function createMock[功能]Data(overrides = {}) {
  const defaults = {
    // 默认测试数据
  };
  return { ...defaults, ...overrides };
}

function createMock[功能]Records(count = 5) {
  // 批量生成测试数据
}
```

### Chrome API Mock

参考 [tests/helpers/chrome-mock.js](mdc:tests/helpers/chrome-mock.js)：

- `ChromeStorageMock` - 模拟storage.sync和storage.local
- `ChromeRuntimeMock` - 模拟runtime.sendMessage
- `ChromeTabsMock` - 模拟tabs API

**重要**：数组检查必须在对象检查之前（因为数组也是对象）

## 测试顺序和依赖

### 推荐的开发流程

1. **先写单元测试** → 快速反馈（约1秒）
2. **再写集成测试** → 验证交互（约1秒）  
3. **最后写E2E测试** → 完整验证（约30-60秒）

### 测试运行命令

```bash
# 开发时（快速反馈）
npm run test:unit

# 提交前（完整验证）
npm run test:all

# 监听模式（实时测试）
npm run test:watch
```

## E2E测试最佳实践

### 1. 使用真实网页

```javascript
// ✅ 推荐 - 使用公开稳定的网站
await page.goto('https://www.baidu.com');
await page.goto('https://example.com');

// ❌ 避免 - 可能失败或被封
await page.goto('https://some-random-site.com');
```

### 2. 验证数据变化而非API可用性

```javascript
// ✅ 正确 - 验证实际效果
const初始Count = await getRecordCount();
// ... 执行操作 ...
const最终Count = await getRecordCount();
expect(最终Count).toBeGreaterThan(初始Count);

// ❌ 错误 - 在page.evaluate中检查chrome API
const hasAPI = await page.evaluate(() => typeof chrome !== 'undefined');
```

### 3. 充分等待

```javascript
await page.goto('https://example.com');
await wait(2000); // 等待content script加载

await page.click('#button');
await wait(1000); // 等待动作完成

// 对于异步操作，等待更长时间
await wait(3000);
```

### 4. 添加调试日志

```javascript
console.log('🔧 扩展ID:', extensionId);
console.log('✅ 配置已保存');
console.log('📊 最终记录数:', count);
```

## 新功能测试清单

添加新功能时，必须包含：

- [ ] 单元测试文件 `tests/unit/[功能].test.js`
- [ ] 至少5个测试用例（正常、边界、错误）
- [ ] 集成测试文件 `tests/integration/[功能].test.js`
- [ ] 测试Chrome API交互
- [ ] E2E测试文件 `tests/e2e/[功能].test.js`
- [ ] 测试真实浏览器环境
- [ ] 更新fixtures.js添加测试数据生成器
- [ ] 所有测试必须通过：`npm run test:all`

## 常见问题和解决方案

### 问题：E2E测试超时

**解决**：增加timeout参数
```javascript
test('测试名称', async () => {
  // 测试代码
}, 60000); // 60秒超时
```

### 问题：Content script没有运行

**检查**：
- URL是否是https://或http://
- manifest.json中的matches配置是否正确
- 是否等待了足够的时间让script加载

### 问题：IndexedDB测试失败

**解决**：确保tests/setup.js中有structuredClone polyfill

### 问题：测试之间相互影响

**解决**：在beforeEach和afterEach中清理状态
```javascript
beforeEach(async () => {
  await clearAllData();
  setupChromeMock();
});

afterEach(async () => {
  resetChromeMock();
});
```

## 性能测试指南

对于影响性能的功能，添加性能测试：

```javascript
test('应该在合理时间内完成', async () => {
  const start = Date.now();
  
  await myFunction();
  
  const duration = Date.now() - start;
  expect(duration).toBeLessThan(1000); // 应该在1秒内完成
});
```

## CI/CD集成

参考 [.github/workflows/test.yml](mdc:.github/workflows/test.yml)：

- 在GitHub Actions中自动运行
- 多Node版本测试
- 生成覆盖率报告
- E2E测试使用xvfb（Linux环境）

## 参考文件

- 单元测试示例：[tests/unit/db.test.js](mdc:tests/unit/db.test.js)
- 集成测试示例：[tests/integration/storage.test.js](mdc:tests/integration/storage.test.js)
- E2E测试示例：[tests/e2e/tracking.test.js](mdc:tests/e2e/tracking.test.js)
- 测试工具：[tests/helpers/chrome-mock.js](mdc:tests/helpers/chrome-mock.js)
- 测试配置：[jest.config.js](mdc:jest.config.js)

## 成功标准

新功能测试完成的标准：
- ✅ 至少10个测试用例
- ✅ 覆盖正常流程、边界情况、错误处理
- ✅ 单元测试 + 集成测试 + E2E测试都有
- ✅ `npm run test:all` 100%通过
- ✅ 测试覆盖率 >60%
